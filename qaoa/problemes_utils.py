import numpy as np

from qiskit.quantum_info import SparsePauliOp
from qiskit.circuit.library import QAOAAnsatz
from qiskit.providers import BackendV2 as Backend
from qiskit_ibm_runtime import SamplerV2 as Sampler
from qiskit_ibm_runtime import EstimatorV2 as Estimator
from qiskit_aer import AerSimulator
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager


def compute_exact_sol(hamiltonian: SparsePauliOp) -> tuple[float, list[str]]:
    """ Classical computation of the inputted Hamiltonian's solutions.
        Done by diagonalizing the Hamiltonian's matrix representation.

    Args:
        Hamiltonian (SparsePauliOp): Hamiltonian to diagonalize, expressed as a sum of Pauli strings.

    Returns:
        tuple[float, list[str]]:
            - minimal cost obtained (float)
            - List of the binary solutions associated to the minimal cost
    """
    # Write the Hamiltonian as a matrix
    mat_hamiltonian = np.array(hamiltonian.to_matrix())
    # Diagonalize the matrix to extract the eigenvectors and eigenvalues
    eigenvalues, eigenvects = np.linalg.eig(mat_hamiltonian)

    # Indices associated to the minimal eigenvalues
    min_eigenval = np.where(eigenvalues == np.min(eigenvalues))[0]
    # Minimal solutions associated to the minimal eigenvalues
    binary_sols = [bin(idx).lstrip("-0b").zfill(hamiltonian.num_qubits) for idx in min_eigenval]

    # Cost and binary strings of the best solutions
    return eigenvalues[min_eigenval][0].real, binary_sols


def calc_score(
    params: np.ndarray, num_layers: int, hamiltonian: SparsePauliOp, backend: Backend
) -> tuple[float, float]:
    """Computes the score associated to the inputted optimal parameters, for a quantum circuit containing the specified number of layers.

    Args:
        params (np.ndarray): Optimal parameters found during optimization.
        num_layers (int): Number of layers in the QAOA circuit.
        hamiltonian (SparsePauliOp): Problem hamiltonian expressed as a sum of Pauli strings (cost function)
        backend (Backend): Backend used to instanciate an Estimator or Sampler.

    Returns:
        tuple[float, float]: Optimal cost and score (%) of the found solution.
    """
    # Building the QAOA circuit
    circuit = QAOAAnsatz(hamiltonian, reps=num_layers)
    # Compute the exact solutions for comparison purposes
    _, binary_sol = compute_exact_sol(hamiltonian)

    # Generate the probability distribution with the specified optimal parameters
    sampler = Sampler(mode=backend)
    circuit_copy = circuit.decompose(reps=2).copy()
    circuit_copy.measure_all()
    data = sampler.run([(circuit_copy, params)]).result()[0].data.meas
    counts = data.get_counts()
    nb_shots = data.num_shots

    # Compute the score (ratio of the percentage of good solutions found to the number of shots used while running the algorithm)
    score = 0
    for sol in binary_sol:
        if sol in counts:
            score += counts[sol]
    score /= nb_shots
    score *= 100.0

    # Compute the average value of the cost function obtained with the specified optimal parameters
    estimator = Estimator(mode=backend)
    pm = generate_preset_pass_manager(backend=estimator._backend, optimization_level=1)
    isa_psi = pm.run(circuit)
    isa_observables = hamiltonian.apply_layout(isa_psi.layout)
    cost = estimator.run([(isa_psi, isa_observables, params)]).result()[0].data.evs

    print("Optimal cost : ", cost)
    print("Score : ", score)
    return cost, score


def save_res(filename: str, params: np.ndarray, num_layers: int, hamiltonian: SparsePauliOp):
    """Saves your optimal parameters and optimal QAOA circuit. The saved file must be submitted to the mentors.

    Args:
        filename (str): Name of the saved file. Use a significant name for your submission.
        params (np.ndarray): Optimal parameters found during optimization.
        num_layers (int): Number of layers in the QAOA circuit.
        hamiltonian (SparsePauliOp): Problem hamiltonian expressed as a sum of Pauli strings (cost function)
    """
    np.savez(file=filename, params=params, num_layers=num_layers, hamiltonian=hamiltonian)


def read_res(filename: str):
    """Reads the information stored in the file generated by the function directly above

    Args:
        filename (str):  Name of the file where you saved your optimal hyperparameters.

    Returns:
        tuple[float, int, SparsePauliOp]: The optimal parameters, number of circuit layers and hamiltonian that were saved.
    """
    file = np.load(filename)
    params = file["params"]
    num_layers = file["num_layers"]
    hamiltonian = file["hamiltonian"]

    return params, num_layers, hamiltonian


def main():
    params, num_layers, hamiltonian = read_res("AgnicoEagle-CSF_sol1.npz")
    print(params, num_layers, hamiltonian)
    cost, score = calc_score(params=params, num_layers=num_layers, hamiltonian=hamiltonian, backend=AerSimulator())

    eigenvalues, binary_sols = compute_exact_sol(hamiltonian)

    print("Score", score)
    print("Solutions", binary_sols)


if __name__ == "__main__":
    main()
